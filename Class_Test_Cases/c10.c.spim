
	.text 			# The .text assembler directive indicates
	.globl func_		# The following is the code (as oppose to data)
func_:				# .globl makes main know to the 
				# outside of the program.
# Prologue begins 
	sw $ra, 0($sp)		# Save the return address
	sw $fp, -4($sp)		# Save the frame pointer
	sub $fp, $sp, 8		# Update the frame pointer

	sub $sp, $sp, 8		# Make space for the locals
# Prologue ends

	lw $v0, 12($fp)		# Source:n_
	j Label3

Label3:    	
	move $v1, $v0		# Source:temp0
	j epilogue_func_

# Epilogue Begins
epilogue_func_:
	add $sp, $sp, 8
	lw $fp, -4($sp)  
	lw $ra, 0($sp)   
	jr        $31		# Jump back to the called procedure
# Epilogue Ends


	.text 			# The .text assembler directive indicates
	.globl main		# The following is the code (as oppose to data)
main:				# .globl makes main know to the 
				# outside of the program.
# Prologue begins 
	sw $ra, 0($sp)		# Save the return address
	sw $fp, -4($sp)		# Save the frame pointer
	sub $fp, $sp, 8		# Update the frame pointer

	sub $sp, $sp, 48		# Make space for the locals
# Prologue ends

	li $v0, 5		# Source:5
	sw $v0, 0($sp)
	sub $sp, $sp, 4
	jal func_
	add $sp, $sp, 4
	sw $v1, -36($fp)	# Dest: a_
	la $t0, -24($fp)		# Loading the address of base:x_
	lw $t1, d_		# Source:d_
	add $t0, $t0, $t1	# Address of Opd1:x_, offset:d_
	lw $t2, 0($t0)		# Indirect load of the final result
	move $t3, $t2		# Result:temp2, Register move of Opd1:x_.d_
	li $t2, 5		# Source:5
	la $t2, -24($fp)		# Loading the address of base:x_
	lw $t4, d_		# Source:d_
	add $t2, $t2, $t4	# Address of Opd1:x_, offset:d_
	lw $t5, 0($t2)		# Indirect load of the final result
	move $t6, $t5		# Result:temp3, Register move of Opd1:x_.d_
	la $t5, -12($fp)		# Loading the address of base:y_
	lw $t7, d_		# Source:d_
	add $t5, $t5, $t7	# Address of Opd1:y_, offset:d_
	lw $t8, 0($t5)		# Indirect load of the final result
	move $t9, $t8		# Result:temp4, Register move of Opd1:y_.d_
	add $t8, $t6, $t9	# Result:temp5, Opd1:temp3, Opd2:temp4
	sw $t8, -40($fp)	# Dest: m_
	la $t6, -24($fp)		# Loading the address of base:x_
	lw $t8, d_		# Source:d_
	add $t6, $t6, $t8	# Address of Opd1:x_, offset:d_
	lw $t9, 0($t6)		# Indirect load of the final result
	move $s0, $t9		# Result:temp6, Register move of Opd1:x_.d_
	sw $s0, -40($fp)	# Dest: m_
	la $t8, -32($fp)		# Loading the address of base:l_
	lw $t9, var_		# Source:var_
	add $t8, $t8, $t9	# Address of Opd1:l_, offset:var_
	lw $s0, 0($t8)		# Indirect load of the final result
	move $s1, $s0		# Result:temp7, Register move of Opd1:l_.var_
	la $s0, -24($fp)		# Loading the address of base:x_
	lw $s2, d_		# Source:d_
	add $s0, $s0, $s2	# Address of Opd1:x_, offset:d_
	lw $s3, 0($s0)		# Indirect load of the final result
	move $s4, $s3		# Result:temp8, Register move of Opd1:x_.d_
	add $s3, $s1, $s4	# Result:temp9, Opd1:temp7, Opd2:temp8
	sw $s3, -36($fp)	# Dest: a_
	la $s1, -32($fp)		# Loading the address of base:l_
	lw $s3, var_		# Source:var_
	add $s1, $s1, $s3	# Address of Opd1:l_, offset:var_
	lw $s4, 0($s1)		# Indirect load of the final result
	move $s5, $s4		# Result:temp10, Register move of Opd1:l_.var_
	sw $s5, -36($fp)	# Dest: a_

# Epilogue Begins
epilogue_main:
	add $sp, $sp, 48
	lw $fp, -4($sp)  
	lw $ra, 0($sp)   
	jr        $31		# Jump back to the called procedure
# Epilogue Ends

